
fn stage_ast(b: Build) {

    if b.verbose > 2 : b.log("> Stage 3: Parse function ASTs")

    // Parse
    parse_asts(b)
    
    // Objects
    each b.units as unit {
        stage_object(unit)
    }

    stage_link(b)
}

fn parse_asts(b: Build) {
    while true {
        let parse_count : uint = 0
        each b.ast_pipeline as func {
            if func.from_header : continue

            if func.parsed_ast {
                if (!func.tracks_classes || func.tracked_classes == b.classes.length)
                && (!func.tracks_globals || func.tracked_globals == b.globals.length)
                {
                    continue
                }
            }

            func.parsed_ast = true
            func.tracked_classes = b.classes.length
            func.tracked_globals = b.globals.length

            parse_func_ast(func)

            func_ir(func)
            func.wipe_ast()
            parse_count++
        }

        if parse_count == 0 {
            break
        }
    }
}

fn parse_func_ast(func: Func) {
    let body = func.chunk_body
    if !isset(body) : panic("Missing function body")

    let b = func.build
    if b.verbose > 2 : b.log("> Stage 3.1: Parse function AST: " + func.display_name)

    let p = Parser.new(body, null)
    p.func = func
    p.decl_scope = func.scope

    // Full AST reset
    func.wipe_ast()

    // Declarations
    func_declare_base_decls(func)

    // Parse
    read_ast(p, func.scope, false)

    p.func = null
    p.decl_scope = null

    func_calculate_alloca_size(func)
    func_generate_alloca_scope(func)
}

fn func_declare_base_decls(func: Func) {
    let b = func.build

    let frame_decl = Decl.new(type_ptr(b), false)
    frame_decl.is_mut = true
    let gc_count_decl = Decl.new(type_uint(b), false)
    gc_count_decl.is_mut = true
    let alloca_size_decl = Decl.new(type_uint(b), false)
    alloca_size_decl.is_mut = true

    func.scope.add_decl(frame_decl)
    func.scope.add_decl(gc_count_decl)
    func.scope.add_decl(alloca_size_decl)

    each func.rett_decls as decl {
        func.scope.add_decl(decl)
    }
    each func.args as arg {
        func.scope.set_idf_b(b, arg.name, Idf.for_decl(arg.decl))
        func.scope.add_decl(arg.decl)
    }
}

fn func_calculate_alloca_size(func: Func) {
    let b = func.build
    let scope = func.scope

    let gc_count: uint = 0
    let alloca_size: uint = 0
    let decls = scope.decls
    let new_list = Array[Decl].new(decls.length)
    each decls as i, decl {
        if i < 3 {
            decl.offset = alloca_size
            alloca_size += decl.type.size()
            alloca_size = alloca_size.round_up(b.ptr_size)
            new_list.push(decl)
            continue;
        }
        if !decl.is_gc : continue
        if decl.is_mut || !decl.is_arg {
            decl.offset = gc_count++
            new_list.push(decl)
        }
    }
    each decls as i, decl {
        if decl.is_gc && (decl.is_mut || !decl.is_arg) : continue
        if decl.is_mut {
            decl.offset = alloca_size
            alloca_size += decl.type.size()
            alloca_size = alloca_size.round_up(b.ptr_size)
        }
        if i > 2 {
            new_list.push(decl)
        }
    }
    scope.decls = new_list

    func.gc_decl_count = gc_count
    func.alloca_size = alloca_size
}

fn func_generate_alloca_scope(func: Func) {
    let b = func.build
    let func_scope = func.scope
    let alloca_scope = func.scope_alloca
    let defer_scope = func.scope_defer

    if !func.is_entrance {
        func_scope.ast.prepend(Token { type: tk_inline_scope, scope1: alloca_scope })
    }

    let decls = func.scope.decls
    let frame_decl = decls.get(0) ! b.error("Missing base declaration (1) (bug)")
    let gc_decl = decls.get(1) ! b.error("Missing base declaration (2) (bug)")
    let asize_decl = decls.get(2) ! b.error("Missing base declaration (3) (bug)")

    let ast = alloca_scope.ast

    each decls as decl {
        if !decl.is_mut : continue
        if decl.is_gc : continue
        if decl.is_arg : continue
        ast.push(Token {
            type: tk_assign
            value1: vgen_decl(decl)
            value2: decl.type.is_pointer ? vgen_null(type_ptr(b)) : vgen_int(0, type_uint(b))
        })
    }

    ast.push(Token {
        type: tk_assign
        value1: vgen_decl(frame_decl)
        value2: vgen_cast(vgen_int(123, type_uint(b)), type_ptr(b))
    })
    ast.push(Token {
        type: tk_assign
        value1: vgen_decl(gc_decl)
        value2: vgen_int(555, type_uint(b))
    })
    ast.push(Token {
        type: tk_assign
        value1: vgen_decl(asize_decl)
        value2: vgen_int(func.alloca_size @as int, type_uint(b))
    })

    if func.gc_decl_count > 0 {

        ///////////////////////////
        // Function start
        ///////////////////////////

        ast.push(Token {
            type: tk_ir_comment
            string1: "INCREASE GC STACK"
        })

        let stackg = b.valk_global("gc", "stack_active")
        let stack = vgen_cached(vgen_global(stackg))
        let class = stack.rett.class
        if !isset(class) : b.error("Missing stack_active type class (bug)")
        let adr_prop = class.props.get("adr") ! b.error("Missing stack_active.adr property (bug)")
        let adr = vgen_prop(adr_prop, stack)
        let adr_cached = vgen_cached(adr)

        func.cache_stack_adr = adr_cached

        ast.push(Token {
            type: tk_statement
            value1: adr_cached
        })

        let amount = vgen_int((func.gc_decl_count * b.ptr_size) @as int, b.valk_type("type", "uint"))
        let offset = vgen_ptr_offset(adr_cached, amount)
        ast.push(Token {
            type: tk_assign
            value1: adr_cached
            value2: offset
        })

        ast.push(Token {
            type: tk_gc_offsets
        })

        ///////////////////////////
        // Function defer
        ///////////////////////////

        ast = defer_scope.ast

        ast.push(Token {
            type: tk_ir_comment
            string1: "REDUCE GC STACK"
        })

        ast.push(Token {
            type: tk_assign
            value1: adr_cached
            value2: adr_cached
        })
    }
}
